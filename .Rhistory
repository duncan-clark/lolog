unlist(edges))
net <- network(edges,directed = F)
for(i in 1:dim(data$marks)[2]){
set.vertex.attribute(net,names(data$marks)[i],data$marks[,i])
}
order = data$marks[order]
formula <- as.formula(paste("net ~",formula_rhs, "|",order))
points <- mapply(data$x,data$y,FUN = function(x,y){
c(x,y)},
SIMPLIFY=FALSE)
edges <- lapply(1:data$n,function(i){
point <- points[[i]]
dists <- sapply(points,FUN=function(x){
dist_func(x,point)
})
return(which(dists < relation_dist ))
})
edges <- cbind(unlist(lapply(1:data$n,function(i){rep(i,times = length(edges[[i]]))})),
unlist(edges))
net <- network(edges,directed = F)
for(i in 1:dim(data$marks)[2]){
set.vertex.attribute(net,names(data$marks)[i],data$marks[,i])
}
order = data$marks[order]
points <- mapply(data$x,data$y,FUN = function(x,y){
c(x,y)},
SIMPLIFY=FALSE)
edges <- lapply(1:data$n,function(i){
point <- points[[i]]
dists <- sapply(points,FUN=function(x){
dist_func(x,point)
})
return(which(dists < relation_dist ))
})
edges <- cbind(unlist(lapply(1:data$n,function(i){rep(i,times = length(edges[[i]]))})),
unlist(edges))
net <- network(edges,directed = F)
for(i in 1:dim(data$marks)[2]){
set.vertex.attribute(net,names(data$marks)[i],data$marks[,i])
}
order
data$markfs
data$marks
order
order = "diameter"
order = data$marks[order]
formula <- as.formula(paste("net ~",formula_rhs, "|",order))
formula
order = 'diameter'
points <- mapply(data$x,data$y,FUN = function(x,y){
c(x,y)},
SIMPLIFY=FALSE)
edges <- lapply(1:data$n,function(i){
point <- points[[i]]
dists <- sapply(points,FUN=function(x){
dist_func(x,point)
})
return(which(dists < relation_dist ))
})
edges <- cbind(unlist(lapply(1:data$n,function(i){rep(i,times = length(edges[[i]]))})),
unlist(edges))
net <- network(edges,directed = F)
for(i in 1:dim(data$marks)[2]){
set.vertex.attribute(net,names(data$marks)[i],data$marks[,i])
}
formula <- as.formula(paste("net ~",formula_rhs, "|",order))
order = data$marks[order]
order
formula
formula_rhs
formula_rhs = "edges + triangles + star(c(2,3))"
#get network edge from the points available
#for each point find neighbours
points <- mapply(data$x,data$y,FUN = function(x,y){
c(x,y)},
SIMPLIFY=FALSE)
edges <- lapply(1:data$n,function(i){
point <- points[[i]]
dists <- sapply(points,FUN=function(x){
dist_func(x,point)
})
return(which(dists < relation_dist ))
})
edges <- cbind(unlist(lapply(1:data$n,function(i){rep(i,times = length(edges[[i]]))})),
unlist(edges))
net <- network(edges,directed = F)
for(i in 1:dim(data$marks)[2]){
set.vertex.attribute(net,names(data$marks)[i],data$marks[,i])
}
formula <- as.formula(paste("net ~",formula_rhs, "|",order))
order = data$marks[order]
order
order = "diameter"
#get network edge from the points available
#for each point find neighbours
points <- mapply(data$x,data$y,FUN = function(x,y){
c(x,y)},
SIMPLIFY=FALSE)
edges <- lapply(1:data$n,function(i){
point <- points[[i]]
dists <- sapply(points,FUN=function(x){
dist_func(x,point)
})
return(which(dists < relation_dist ))
})
edges <- cbind(unlist(lapply(1:data$n,function(i){rep(i,times = length(edges[[i]]))})),
unlist(edges))
net <- network(edges,directed = F)
for(i in 1:dim(data$marks)[2]){
set.vertex.attribute(net,names(data$marks)[i],data$marks[,i])
}
formula <- as.formula(paste("net ~",formula_rhs, "|",order))
formula
diameter()
diameter
order = data$marks[order]
order
assign(order,data$marks[order])
points <- mapply(data$x,data$y,FUN = function(x,y){
c(x,y)},
SIMPLIFY=FALSE)
edges <- lapply(1:data$n,function(i){
point <- points[[i]]
dists <- sapply(points,FUN=function(x){
dist_func(x,point)
})
return(which(dists < relation_dist ))
})
edges <- cbind(unlist(lapply(1:data$n,function(i){rep(i,times = length(edges[[i]]))})),
unlist(edges))
net <- network(edges,directed = F)
for(i in 1:dim(data$marks)[2]){
set.vertex.attribute(net,names(data$marks)[i],data$marks[,i])
}
formula <- as.formula(paste("net ~",formula_rhs, "|",order))
assign(order,data$marks[order])
diameter
order
order = "diameter"
order
formula_rhs
points <- mapply(data$x,data$y,FUN = function(x,y){
c(x,y)},
SIMPLIFY=FALSE)
edges <- lapply(1:data$n,function(i){
point <- points[[i]]
dists <- sapply(points,FUN=function(x){
dist_func(x,point)
})
return(which(dists < relation_dist ))
})
edges <- cbind(unlist(lapply(1:data$n,function(i){rep(i,times = length(edges[[i]]))})),
unlist(edges))
net <- network(edges,directed = F)
for(i in 1:dim(data$marks)[2]){
set.vertex.attribute(net,names(data$marks)[i],data$marks[,i])
}
formula <- as.formula(paste("net ~",formula_rhs, "|",order))
assign(order,data$marks[order])
diameter
formula_rhs
formula
lolog = lolog(formula)
diameter
is.numeric(diameter)
type(diameter)
class(diameter)
data$marks[order][,1]
order
assign(order,data$marks[order][,1])
diameter
lolog = lolog(formula)
formula_rhs = "edges + triangles"
formula <- as.formula(paste("net ~",formula_rhs, "|",order))
assign(order,data$marks[order][,1])
lolog = lolog(formula)
summary(lolog)
plot(net)
formula_rhs = "edges + triangles + star(c(2,3))"
formula <- as.formula(paste("net ~",formula_rhs, "|",order))
assign(order,data$marks[order][,1])
lolog = lolog(formula)
lolog
summary(lolog)
formula_rhs
formula_rhs ="edges + triangles + star(c(2,3))"
formula_rhs
formula_rhs ="edges + triangles + star(2)"
formula <- as.formula(paste("net ~",formula_rhs, "|",order))
assign(order,data$marks[order][,1])
lolog = lolog(formula)
formula_rhs ="edges + triangles + star(2) + nodeCov("height")"
formula_rhs ="edges + triangles + star(2) + nodeCov('height'')"
formula <- as.formula(paste("net ~",formula_rhs, "|",order))
assign(order,data$marks[order][,1])
lolog = lolog(formula)
formula <- as.formula(paste("net ~",formula_rhs, "|",order))
formula_rhs ="edges + triangles + star(2) + nodeCov('height')"
formula <- as.formula(paste("net ~",formula_rhs, "|",order))
assign(order,data$marks[order][,1])
lolog = lolog(formula)
formula_rhs
formula_rhs ="edges + triangles + nodeCov('height')"
formula <- as.formula(paste("net ~",formula_rhs, "|",order))
assign(order,data$marks[order][,1])
lolog = lolog(formula)
lolog
summary(lolog)
plot(net)
plot(net,cex = get.vertex.attribute(net,"height"))
get.vertex.attribute(net,"height")
help(plot.network)
plot(net,vertex.cex = get.vertex.attribute(net,"height"))
plot(net,vertex.cex = get.vertex.attribute(net,"height")/10)
plot(net,vertex.cex = get.vertex.attribute(net,"height")/2)
plot(finpines$x,finpines$y)
rm(list=ls())
Rcpp::sourceCpp('Academics/UCLA_Academics/Networks/lolog/src/RcppModule.cpp')
Rcpp::sourceCpp('Academics/UCLA_Academics/Networks/lolog/src/RcppModule.cpp')
Rcpp::sourceCpp('Academics/UCLA_Academics/Networks/lolog/src/RcppModule.cpp')
Rcpp::sourceCpp('Academics/UCLA_Academics/Networks/lolog/src/RcppModule.cpp')
Rcpp::sourceCpp('Academics/UCLA_Academics/Networks/lolog/src/RcppModule.cpp')
source('~/Academics/UCLA_Academics/Networks/lolog_builder.R', echo=TRUE)
library(Blolog)
library(statnet)
library(lolog)
library(coda)
library(doParallel)
library(ggplot2)
require(bootlog)
setwd("C:/Users/Duncan/Documents/Academics/UCLA_Academics/Networks/LOLOG_Cateloging/1_16_KapfererTailors")
load("processed_data.RData")
model <- lolog(net_1 ~ edges + triangles + star(c(2,3)))
n <- get.network.attribute(net_1,"n")
e <- choose(n,2)
star_2 <- n*choose((n-1),2)
star_3 <- n*choose((n-1),3)
triangle <- choose(n,3)
randomwalk_sigma <- diag(e/c(e,triangle,star_2,star_3),4)/1000
cov_start <- diag(e/c(e,triangle,star_2,star_3),4)*10
net
net_1
net <- net_!
net <- net_1
formula = as.formula("net~ edges + triangles + star(c(2,3))")
theta = c(0,0,0,0)
model <- lolog::createLatentOrderLikelihood(formula,theta = q)
formula
theta
lolog::lologVariational(foemula)
lolog::lologVariational(formula)
q <- lolog::lologVariational(formula)
model <- lolog::createLatentOrderLikelihood(formula,theta = q)
theta
q
q <- as.list(q)
q
q[[1]]
q[[2]]
q[[3]]
q <- q[[3]]
model <- lolog::createLatentOrderLikelihood(formula,theta = q)
e
s = sample(1:e,e)
n = 39
edges <- combn(seq(1,n),2)
tails <- edges[1,][s]-1
heads <- edges[2,][s]-1
model <- lolog::createLatentOrderLikelihood(formula,theta = q)
sims = 2
sims <- lapply(1:proposal_sims,function(x){lolog::as.network(model$generateNetworkWithEdgeOrder(heads,tails)$network)})
proposal_sims = 2
sims <- lapply(1:proposal_sims,function(x){lolog::as.network(model$generateNetworkWithEdgeOrder(heads,tails)$network)})
sims
tmp <- model$generateNetworkWithEdgeOrder(heads,tails)
tmp$changeStats
length(tmp)
length(tmp$changeStats)
net
length(head)
length(heads
)
length(tails)
tmp$changeStats[1:10]
tmp
change = tmp[741:1482]
lenth(change)
length(change)
mapply(change,lolog_change_stats(tmp$network,s,"edges + triangles + star(c(2,3,))"),FUN = function(x,y){sum(x==y)==length(x)},SIMPLIFY = F)
mapply(change,lolog_change_stats(tmp$network,s,"edges + triangles + star(c(2,3))"),FUN = function(x,y){sum(x==y)==length(x)},SIMPLIFY = F)
mapply(change,lolog_change_stats(tmp$network,s,"edges + triangles + star(c(2,3))"),FUN = function(x,y){sum(x==y)==length(x)},SIMPLIFY = F)
tmp_network <- lolog::as.network(tmp$network)
mapply(change,lolog_change_stats(tmp_network,s,"edges + triangles + star(c(2,3))"),FUN = function(x,y){sum(x==y)==length(x)},SIMPLIFY = F)
mapply(change,lolog_change_stats(tmp_network,s,"edges + triangles + star(c(2,3))"),FUN = function(x,y){sum(x==y)==length(x)},SIMPLIFY = T)
test = mapply(change,lolog_change_stats(tmp_network,s,"edges + triangles + star(c(2,3))"),FUN = function(x,y){sum(x==y)==length(x)},SIMPLIFY = T)
test
type(test)
class(test)
sum(test)
length(test)
Rcpp::sourceCpp('~/Academics/UCLA_Academics/Networks/lolog/src/RcppModule.cpp')
source('~/Academics/UCLA_Academics/Networks/lolog_builder.R', echo=TRUE)
sims <- lapply(1:proposal_sims,function(x){lolog::as.network(model$generateNetworkWithEdgeOrder(heads,tails)$network)})
RMHMC_sim_proposal <- function(theta_0, #the current paramter value - starting position for HMC
net, #the observed network,
s, #the fixed edge permutation
formula_rhs,    #rhs formula of model
prior = function(theta){(sum(abs(theta)<10) == length(theta))*((1/20)**length(theta))}, #prior function for theta
prior_grad = NULL, #specify prior derivative to get speed up
L_steps, #the number of leapfrog steps
epsilon = NULL, #size of the leapfrog step
epsilon_factor = 1, #used when epsilon is null to amend the generate "ideal epsilon"
momentum_sigma, #sigma used in momentum function generator
change_off = NULL,
change_on = NULL,
proposal_sims = 40,#number of sims used for the calculation of Hessian
...
){
#Rename the theta_0 as q - in line with HMC literature
q <- theta_0
names(q) <- NULL
#Make the lolog formula
formula <- as.formula(paste("net ~",formula_rhs,sep = ""))
#calculate the change stats for the given permutaion and graph
if(is.null(change_off)){
tmp <- lolog_change_stats(net,s,formula_rhs)
change_on <- tmp$change_on
change_off <- tmp$change_off
}
#From s get the permutation heads and tails:
edges <- combn(seq(1,n),2)
tails <- edges[1,][s]-1
heads <- edges[2,][s]-1
#Calculate gradient of the log prior + log liklihood function for LOLOG
q_grad <- function(q,change_on=NULL,network=NULL){
if(is.null(network)){
network <- net_1
}
if((is.null(change_on))){
change_on <- lolog_change_stats(network,s,formula_rhs)
}
if(is.null(prior_grad)){
prior_deriv <- (numDeriv::grad(prior,q)/prior(q))
}
else{prior_deriv <- prior_grad(q)/prior(q)}
if(sum(is.na(prior_deriv)) != 0){
prior_deriv <- rep(0,length(q))
}
#derivative of change statistics on top
#is just graph statistics
top_deriv <- lolog::calculateStatistics(as.formula(paste("network ~ ",formula_rhs)))
bottom_deriv <- bottom_deriv_helper_cpp(change_on,q)
#return their sum with the correct signs
return(-prior_deriv - top_deriv  + bottom_deriv)
}
#specify a local momentum matrix if no momentum is supplied:
#it is the local covariance matrix at the starting point
#"ideal" dynamics under the assumption that the proposal distribution is Gaussian are sampling the momentum from the inverse covariance matrix
momentum_assign <- function(q){
model <- lolog::createLatentOrderLikelihood(formula,theta = q)
momentum_sigma <- lapply(1:proposal_sims,function(i){
tmp = model$generateNetworkWithEdgeOrder(heads,tails)
grad = q_grad(q,change_on = tmp$changeStats, network = lolog::as.network(tmp$network))
return(outer(grad,grad))
})
momentum_sigma <- Reduce("+",momentum_sigma)/length(momentum_sigma)
#check if singular
if(abs(det(momentum_sigma)) < 10**(-6)){
for(i in 10**seq(-6,20,1)){
if(abs(det(momentum_sigma))>10**(-6)){
break
}
else{
momentum_sigma <- momentum_sigma + diag(min(diag(momentum_sigma))*i,dim(momentum_sigma)[1])
}
}
}
momentum_sigma_inv <- solve(momentum_sigma)
assign("momentum_sigma",momentum_sigma, envir = parent.env(environment()))
assign("momentum_sigma_inv",momentum_sigma_inv, envir = parent.env(environment()))
# print("Momentum is :")
# print(momentum_sigma)
# print("Momentum inversed is:")
# print(momentum_sigma_inv)
# print("Momentum Assigned")
return()
}
#debug(momentum_assign)
momentum_assign(q)
#If epsilon is null put it as the mimimum eigen value of the momentum matrix:
if(is.null(epsilon)){
epsilon <- (min(eigen(momentum_sigma)$values)**0.5)*epsilon_factor
}
#Generate initial momentum
p_init <- MASS::mvrnorm(1,rep(0,length(q)),Sigma = momentum_sigma)
p <- p_init
#Do half momentum update fist
p <- p - (epsilon/2)*q_grad(q,change_on = change_on)
#Do L_steps full updates
if(L_steps != 1){
for(i in 1:(L_steps-1)){
q <- q + epsilon*(momentum_sigma_inv%*%p)
if(prior(q)==0){
return(list(proposal = as.vector(q), prob_factor = 0))
}
p <- p - epsilon*q_grad(q,change_on = change_on)
#print(q)
#print(p)
#print(momentum_sigma)
#print(det(momentum_sigma))
#print(momentum_sigma_inv)
#print(det(momentum_sigma_inv))
#Update covariance matrix:
momentum_assign(q)
}
}
#Do final updates
q <- q + epsilon*(momentum_sigma_inv%*%p)
p <- p - (epsilon/2)*q_grad(q,change_on = change_on)
#negate the momentum variable - does not actaully effect anything
p <- -p
#prob factor takes account of the joint distribution in the metropolis step
prob_factor = exp(0.5*t(p_init)%*%(momentum_sigma_inv%*%p_init) - 0.5*t(p)%*%(momentum_sigma_inv%*%p))
return(list(proposal = as.vector(q), prob_factor = prob_factor))
}
rm(list=ls())
source('~/Academics/UCLA_Academics/Networks/LOLOG_bayesian/Blolog_build.R', echo=TRUE)
library(Blolog)
library(statnet)
library(lolog)
library(coda)
library(doParallel)
library(ggplot2)
require(bootlog)
setwd("C:/Users/Duncan/Documents/Academics/UCLA_Academics/Networks/LOLOG_Cateloging/1_16_KapfererTailors")
load("processed_data.RData")
model <- lolog(net_1 ~ edges + triangles + star(c(2,3)))
#===== Method 1 ==========#
n <- get.network.attribute(net_1,"n")
e <- choose(n,2)
star_2 <- n*choose((n-1),2)
star_3 <- n*choose((n-1),3)
triangle <- choose(n,3)
randomwalk_sigma <- diag(e/c(e,triangle,star_2,star_3),4)/1000
cov_start <- diag(e/c(e,triangle,star_2,star_3),4)*10
#===== Method 3 ==========#
test_3 <- Blolog(formula_rhs = model$formula[3],
net = net_1,
n_perms = 1,
proposal_step = RMHMC_sim_proposal,
verbose = T,
prior = function(theta){(1/(20**length(theta)))*(sum(theta>20)==0)*(sum(theta < -20)==0)},
prior_deriv = function(theta){rep(0,length(theta))},
samples = 10,
start = function(){formula = as.formula("net ~ edges + triangles + star(c(2,3))",env = parent.frame(2))
lolog::lologVariational(formula)[[3]]},
#start = rep(0,3),
#start = function(){MASS::mvrnorm(1,rep(0,4),diag(c(1,0.5,0.1,0.01)*2))},
diff_perm = F,
cores = NULL,
L_steps = 1,
epsilon = 0.99,
proposal_sims = 50
)
model <- lolog::createLatentOrderLikelihood(formula,theta = q)
net_1 <- net
net <- net_1
formula <- "edges + triangles + star(c(2,3))"
e
s
s <- sample(1:e,e)
edges <- combn(seq(1,n),2)
tails <- edges[1,][s]-1
heads <- edges[2,][s]-1
tmp = model$generateNetworkWithEdgeOrder(heads,tails)
model
model <- lolog::createLatentOrderLikelihood(formula,theta = q)
q
q <- lolog::lologVariational(net ~ edges + triangles + star(c(2,3)))
q
q <- q[[3]]
q
model <- lolog::createLatentOrderLikelihood(formula,theta = q)
formula
formula <- paste("net~ ",formula)
formula
formula <- as.formula(formula)
model <- lolog::createLatentOrderLikelihood(formula,theta = q)
model
tmp = model$generateNetworkWithEdgeOrder(heads,tails)
tmp
tmp$changeStats
length(changeStats)
length(tmp$changeStats)
library(lolog)
tmp = model$generateNetworkWithEdgeOrder(heads,tails)
tmp$changeStats
length(tmp$changeStats)
t <- proc.time()
remove.packages("lolog")
library("devtools")
setwd("C:/Users/Duncan/Documents/Academics/UCLA_Academics/Networks/lolog")
Rcpp::compileAttributes()
tmp <- build(vignettes = FALSE)
install.packages(tmp,type = "source",repos = NULL)
print(proc.time()-t)
model <- lolog::createLatentOrderLikelihood(formula,theta = q)
tmp = model$generateNetworkWithEdgeOrder(heads,tails)
length(tmp$changeStats)
tmp$changeStats[1:10]
tmp$changeStats[742:1482]
getwd()
